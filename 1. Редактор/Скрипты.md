## Механизм внедрения

При добавлении компонента `InjectServices` на `GameObject`, механизм `DI` попытается произвести инъекцию при запуске сцены.  
Одного компонента в корне объекта достаточно, чтобы инъекция была произведена и потомкам.  
Если нужно внедрить что-то вложенным объектам, то передавать `IObjectResolver container`

### Класс C#

Инъекция происходит в обычном режиме, через конструктор при создании.

### MonoBehavior

Компоненту на сцене добавить метод, с нужными параметрами:

```csharp
[VContainer.Inject, JetBrains.Annotations.UsedImplicitly]
private void DependencyInject()
{
}
```

**Воспринимается как конструктор**

## MonoBehavior

### Альтернатива конструктору / Awake (для вложений)

```csharp
public void Initialization()
{
}
```

### SerializeField в виде свойств а не полей

```csharp
/// <summary>
/// {DESC}.
/// </summary>
[field: SerializeField] public Type PropName { get; private set; }
```

### SerializeReference при использовании SubclassSelector

`SubclassSelector` позволяет выбирать нужные типы в полях MonoBehavior через интерфейс юнити (альтернатива другим подходам, например куче компоннетов на GO)

> Чтобы `Type|IType` можно было выбрать в `SubclassSelector`, нужно ВСЕЙ иерархии проставить `[Serializable]` (интерфесу мб и не надо)

```csharp
/// <summary>
/// {DESC}.
/// </summary>
[field: SerializeReference, SubclassSelector]
public Type[] Components { get; private set; } = Array.Empty<Type>();
```

### Для ссылочных полей дополнительные атрибуты

```csharp
NaughtyAttributes.Required("Required PropName")
```
