# Слои (`Sorting Layers`)

-   `Background`: глобальный задний фон
-   `Grid Background`: задний фон сетки сцены
-   `Default`: слой сущностей (у игрока 1 мб потом будет больше)
-   `Grid Foreground`: передние слои сетки сцены

### Слои СЕТКИ сцены (название | слой сортировки | номер в слое):

Указывается в `Tilemap Renderer`

-   `Sketch` (_удаляется после окончания работы над сценой_): **Grid Background**, -1
-   `Background.nn` (задник сцены): _Grid Background_, 0 .. 9
-   `Background.10` (контур карты, последний слой относящийся к заднику): **Grid Background**, 10
-   `Foreground.nn` (передний слой): **Grid Foreground**, 0 .. 9
-   `Colliders` (слой для коллайдеров, без отображения): **Grid Foreground**, 10
    -   отключать компонент `Tilemap Renderer`

> игрок, враги и т. д. отображаются в слое **Default** между **Background.10** и **Foreground.00** (чтобы красиво вместить в окружение)

# Задний фон сцены

-   контейнер фонов: GO `Backgrounds` или любо другой (сюда заносить фоны) и указать в `SceneServices`
-   фон/задник (сюда заносить слои) - `GO` с компонентом `ParallaxBackground` или другой наследник `Background`
    -   всегда указывать `tag: Untagged` и `layer: None`
    -   одновременно может быть **много фонов**
    -   ненужные фоны можно выключить, нужные включить (в любом количестве)
-   слои - `GO` с компонентом `SpriteRenderer`
    -   для слоев одного цвета, под размер камеры, есть префаб `BackgroundLayerFill`: добавить в слои фона и покрасить в нужный цвет
-   **фон или слой** можно менять на другой (или переключать) через `BackgroundService`: плавно (указывается время в секундах) или мгновенно
    -   для триггера есть `ChangeBackgroundAction`, который позволяет указать: фон / слой, длительность в секундах, режим смены состояния и конечное состояние (`IsShow` ? вкл : выкл)

### Структура конечного `GO`:

-   Backgrounds
    -   Background.00
        -   Layer.00
        -   Layer.01
        -   Layer.02

### Реализации `Background`

-   `ParallaxBackground`: состоит из слоев, которы работает как параллакс, двигается относительно одной точки (стартовая). Координаты цели из глобальный пересчитываются в локальные
-   `InfinityParallaxBackground`: аналогично скрипту выше, только является бесконечным - "перепрыгивает" на новые позиции по мере движения цели

#### Настройка фона `ParallaxBackground` (параллакс фон)

> в меню компонента есть кнопка `Create`: заносит все слои и делает первоначальную настройку  
> если **выключен на старте сцены**, от после инициализации сервиса - отключит все слои

-   `Transform`: ссылка на `GO` слоя
-   `ScaleX, ScaleY`: множитель отклонения по `X или Y` фона за камерой (т.е. на сколько сильно может отклониться слой (параллакс))
    -   значение `X:1`, `Y:1` - фон просто будет летать в области камеры
    -   ближние слои двигаются быстрее, чем дальние за счет увелечения значений `X или Y`
    -   отрицательные значения `X или Y`, при движении камеры, смещают слой в обратном направлении (в основном для `Y` при прыжках)
-   `Border`: не влияет
-   при выключении всех слоев (через сервис), корневой `GO` слоя - отключается

#### Настройка фона `InfinityParallaxBackground` (бесконечный параллакс фон)

-   все свойства как у `ParallaxBackground`
-   `Border`: граница объекта для скроллинга фона
    -   при нажатии на фон, у всех слоев подсвечиваются границы, их нужно указывать так, чтобы при перемещении к границе, камеры, фон переставлялся за ней, но на камеру **этого не было видно** (т.е. бесшовно)

# Игровой триггер

-   добавить префаб `GameplayTrigger` в нужном месте, устанавливаем нужный размер (или взять один из вариантов)
-   добавить нужные действия, наследуемые от `GameplayTriggerAction` и `IEnterAction` или `IExitAction` (пример `DoorAction`)
-   настроить добавленные действия(отключения действия на входе/выходе), добавить `GO` для взаимодействия

### Игровой триггер для босса

-   добавить `BossRoomTrigger` в нужном месте, устанавливаем нужный размер
-   выполнить все пункты для `GameplayTrigger`
-   добавить нужные действия наследуемые от `GameplayTriggerAction` и `IRevertAction`

### Готовые префабы

-   `ActivationFastTravelPointTrigger` - активация тбп
-   `BossRoomTrigger` - триггер комнаты босса
-   `DeathZoneTrigger` - зона смерти

# Точка появления игрока (опционально)

-   добавить префаб `StartPointPlayer` в нужное место
-   ссылку на префаб указать в `SceneServices`

# Внешний вид объекта

-   если необходима возможность переключать внешний вид , то нужно установить `SwitchableObjectComponent` на сущность
-   в `Values` устанавливается список переключаемых `gameObject` уже в необходимом состоянии
-   флаг `SwitchOnce` указывает на то, что переключение состояния будет всего один раз
-   флаг `InitialState` указывает текущее состояние является ли изначальным

# Добавление способностей

-   добавить `ListAbilityConverter` на `gameObject`
-   добавить в поле список `ScriptableObject` созданных из `AbilityConfig`
-   настроить время отката способности в каждый `AbilityConfig`
-   добавить в каждый `AbilityConfig` список `AbilityEffect`
-   настроить каждый `AbilityEffect`

# Настройка ИИ

### Включение ИИ у объекта сущности

-   установить `AiTagComponent` на сущность или `AiTagConverter` на `GameObject` для того, чтобы сущность работала с функционалом ИИ

### Настройка блокирования ИИ

-   установить `BlockConfigComponent` на сущность или `BlockConfig` в `EntityConfig` для функционала блокирования у ИИ, `Chance` - вероятность блока, когда "видит" атаку
-   `Time` - время действия блока
-   `ExitZoneTime` - время действия блока, когда игрок вышел

### Настройка путевых точек

-   установить `PatrolPointComponent` на сущность или `PatrolPointConverter` на `GameObject` для включения функционала патрулирования между `WayPoint`, которые указаны в компоненте, для работы необходимо минимум 2 точки. В `WayPoint` можно указать следующие флаги `UseInteraction` и `Jump`
-   `UseInteraction` - для использования внешних предметов на точке
-   `Jump` - для использования прыжка в точке

# Дополнительная свойства

-   `DisabledEntityTag` для отключения взаимодействия c сущностью (на уровне ECS)
-   `EventOuterTagComponent` для отправки внешних событий

# Таймер

Механизм основан на `ecs`. Таймер имеет: оригинальное и оставшееся время, количество итераций  
Тик итерации происходит при **оставшееся время == 0**

Использование:

-   ecs: использовать сборку `Game.Ecs.Timer`
    -   все, что является созданием таймера в других сборках, стараться заносить в фабрику этой сборки
    -   **в теории** фабрику сборки можно использовать в других фабриках для удобства **(? это потестить)**
-   editor / oop code: использовать через DI `TimerService`
    -   позволяет из вне подписываться на `ecs-таймеры`
    -   предусмотрены события: каждый тик, окончание таймера и возможность удаления таймера при смене сцены
    -   при подписке возвращается `IDispose`, который при `Dispose()` удаляет таймер и прекращает обработку
-   важно:
    -   т.к. подписчики работают с `IObjectPool`, то в конце таймера клиент должен обнулять свою ссылку на `IDispose`
    -   событие последнего тика и конца таймера происходят мгновенно, подряд в строгом порядке
